-- [ INLEIDING ] --

De syntax van deze taal vertrok van een schematisch idee op papier. Aangezien mijn schema's doorgaas uitpuilen van de pijltjes, zijn deze blijven staan in de effectieve implementatie van de taal. De naam is afkomstig van het woord Menu en alle identifiers en keywords hebben met eten te maken. De statements met betrekking tot de MBot echter, vormen een uitzondering op deze regel. Inspiratie voor de werking van de taal heb ik geput uit de bestaande talen waarin ik het liefst programmeer, namelijk C, PHP, Python. Een resultaat hiervan is dat booleans geïmplementeerd zijn als getallen 1 en 0, respectievelijk true en false. Elke arithmetische expressie die niet naar 0 evalueert, wordt booleaans true, equivalent met de implementatie in Python.

-- [ SYNTAX BNF ] --

# todo

-- [ SEMNATIEK ] --

* Cook
De naamkeuze voor dit statement was voordehandliggend. Wanneer er gekookt wordt, kan er (nog) niet gegeten worden en moet er dus gewacht worden. Een Cook-statement komt overeen met een sleep of delay uit andere programmeertalen, de evaluatie zal een opgegeven aantal seconden pauzeren.
Dit statement laat toe om de uitvoering van een stuk code te vertragen.

* Eating

* Hungry (Stuffed)

* Order

* Puke

* Review

-- [ PROGRAMMA'S ] --

* fibonacci
* policecar
* linefollower
* obstacle avoid
* tests - zeg ook iets over runtests.sh

-- [ IMPLEMENTATIE ] --
* alle nummers zijn doubles om geen onderscheid te moeten maken tussen gehele getallen en kommagetallen

* whitespace gestript

* modulair (foto van map)

*  bools zijn doubles

* fromjust dingen - gaat crashen maar maakt niet uit want programma kan toch niet werken anders met onbestaande variabelen ezo

-- [ CONCLUSIE ] --
De eerlijkheid gebied mij te vermelden dat ik nog niet alle concepten van Haskell volledig onder de knie heb. Ik ben er van overtuigd dat heel wat methodes nog compacter en/of efficiënter zouden kunnen gemaakt worden, mits ik mij er nog wat in verdiep. Wegens projecten van andere vakken en examens had ik hier echter niet voldoende tijd voor.

* Graag had ik nog ondersteuning voor strings toegevoegd, dit was er oorspronkelijk wel, maar ik kwam ermee in de problemen tijdens waardoor ik dit heb moeten verwijderen. Het werken van de parser had logischerwijs namelijk voorrang op optionele features.

* Github Foto
Zoals te zien is op bovenstaande foto heb ik veel code geschreven en weer weggedaan voor optimalisaties.

* Elke methode is gedocumenteerd volgens Haddock, en documentatie via Haddock werd tevens gegenereerd en bijgevoegd in de docs/ map.

-- [ BRONNEN ] --
https://wiki.haskell.org/Parsing_a_simple_imperative_language
slides - Monads
http://dev.stephendiehl.com/fun/WYAH.pdf
https://cseweb.ucsd.edu/classes/wi12/cse230-a/lectures/parsers.html
http://stackoverflow.com/questions/16970431/implementing-a-language-interpreter-in-haskell
parsec lib voor hulpfuncties
https://en.wikibooks.org/wiki/Haskell/ParseExps
https://www.schoolofhaskell.com/school/starting-with-haskell/basics-of-haskell/12-State-Monad
http://pointfree.io/
http://dev.stephendiehl.com/fun/002_parsers.html
